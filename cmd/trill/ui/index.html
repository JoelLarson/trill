<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trill</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f9fafb;
      --fg: #1c1f26;
      --muted: #666;
      --border: #d0d7de;
      --panel: #ffffff;
      --user: #1d4ed8;
      --assistant: #15803d;
      --error: #b00020;
      --raw-bg: #f2f4f7;
    }
    body.dark {
      --bg: #0d1117;
      --fg: #e6edf3;
      --muted: #9da8b7;
      --border: #2d3748;
      --panel: #161b22;
      --user: #60a5fa;
      --assistant: #34d399;
      --error: #ff6b6b;
      --raw-bg: #1f2733;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: var(--bg);
      color: var(--fg);
    }
    #conversations { margin-top: 10px; }
    .toolbar { display: flex; gap: 10px; align-items: center; margin-bottom: 12px; }
    button { cursor: pointer; }
    input[type="text"] { padding: 6px; }
    .conv { border: 1px solid var(--border); padding: 10px; margin-bottom: 10px; background: var(--panel); }
    .messages { max-height: 200px; overflow-y: auto; border-top: 1px solid var(--border); padding-top: 5px; }
    .msg { margin: 6px 0; }
    .msg.user { color: var(--user); }
    .msg.assistant { color: var(--assistant); }
    .msg.error { color: var(--error); font-style: italic; }
    .status { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .raw-output { background: var(--raw-bg); border: 1px dashed var(--border); padding: 6px; margin-top: 4px; white-space: pre-wrap; font-size: 12px; color: var(--fg); }
    .session { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .session button { margin-left: 6px; }
    .pill { display: inline-block; padding: 2px 6px; border-radius: 4px; border: 1px solid var(--border); margin-right: 6px; }
    .artifact-section { margin-top: 10px; border-top: 1px solid var(--border); padding-top: 8px; }
    .artifact-card { border: 1px dashed var(--border); padding: 8px; margin-top: 6px; background: var(--raw-bg); }
    .artifact-card button { margin-top: 6px; }
    .inbox-item { border: 1px solid var(--border); border-radius: 12px; padding: 10px; margin-top: 8px; background: var(--panel); }
    .inbox-item .status { font-size: 12px; color: var(--muted); }
    .inbox-actions { display: flex; gap: 8px; margin-top: 10px; }
    .final-output {
      margin-top: 12px;
      border: 1px solid #60a5fa;
      background: #dbeafe;
      padding: 10px;
      border-radius: 6px;
      font-weight: 600;
    }
    .final-output .meta {
      font-weight: normal;
      font-size: 13px;
    }
    body.dark .final-output {
      background: #14213d;
      border-color: #38bdf8;
    }
  </style>
</head>
<body>
  <div id="app">
  <h1>Trill</h1>
  <div class="toolbar">
    <input id="promptInput" type="text" placeholder="Enter prompt..." style="flex:1;" />
    <button id="startBtn">Start New Conversation</button>
    <button id="themeToggle">Toggle Theme</button>
  </div>
  <div id="inbox"></div>
  <div id="conversations"></div>
  </div>

  <script>
    const formatSeconds = (ms) => (ms / 1000).toFixed(1) + 's';
    const applyTheme = (mode) => {
      document.body.classList.toggle('dark', mode === 'dark');
      localStorage.setItem('theme', mode);
    };
    const initTheme = () => {
      const stored = localStorage.getItem('theme');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(stored || (prefersDark ? 'dark' : 'light'));
    };
    const fetchConversation = async (id) => {
      const res = await fetch(`/conversation?id=${encodeURIComponent(id)}`);
      if (!res.ok) throw new Error(await res.text() || res.statusText);
      return res.json();
    };
    async function fetchInbox() {
      const res = await fetch('/inbox');
      const list = await res.json();
      const box = document.getElementById('inbox');
      box.innerHTML = '<h3>Inbox</h3>';
      if (!Array.isArray(list) || list.length === 0) {
        box.innerHTML += '<div>No items waiting.</div>';
        return;
      }
      list.forEach((item) => box.appendChild(renderInboxItem(item)));
    }

    function createButton(label, onclick) {
      const button = document.createElement('button');
      button.textContent = label;
      button.onclick = onclick;
      button.style.marginRight = '6px';
      return button;
    }

    function renderInboxItem(item) {
      const card = document.createElement('div');
      card.className = 'inbox-item';
      const header = document.createElement('div');
      header.textContent = `[${item.state}] ${item.prompt || 'Conversation'}`;
      header.className = 'status';
      card.appendChild(header);
      if (item.awaiting_reason) {
        const reason = document.createElement('div');
        reason.className = 'status';
        reason.textContent = item.awaiting_reason;
        card.appendChild(reason);
      }
      if (item.state === 'awaiting_plan_approval') {
        const actions = document.createElement('div');
        actions.className = 'inbox-actions';
        actions.className = 'inbox-actions';
        const approvePlan = createButton('Approve Plan', async () => {
          const resp = await fetch('/conversation/approve-plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: item.session_id }),
          });
          if (!resp.ok) {
            alert(await resp.text());
            return;
          }
          await fetchConversations();
          fetchInbox();
        });
        actions.appendChild(approvePlan);
        card.appendChild(actions);
      }
      if (item.state === 'blocked' && item.pending_command) {
        const stepLine = document.createElement('div');
        stepLine.textContent = `Step: ${item.step_title}`;
        card.appendChild(stepLine);
        const cmdLine = document.createElement('div');
        cmdLine.className = 'status';
        cmdLine.textContent = `Command: ${item.pending_command}`;
        card.appendChild(cmdLine);
        const actions = document.createElement('div');
        const approveCmd = createButton('Approve Command', async () => {
          const resp = await fetch('/conversation/approve-command', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: item.session_id, step_id: item.step_id }),
          });
          if (!resp.ok) {
            alert(await resp.text());
            return;
          }
          await fetchConversations();
          fetchInbox();
        });
        actions.appendChild(approveCmd);
        const resumeBtn = createButton('Resume', async () => {
          const resp = await fetch('/conversation/resume', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: item.session_id }),
          });
          if (!resp.ok) {
            alert(await resp.text());
            return;
          }
          await fetchConversations();
          fetchInbox();
        });
        actions.appendChild(resumeBtn);
        card.appendChild(actions);
      }
      if (item.state === 'completed' && item.completed_message) {
        const summary = document.createElement('div');
        summary.className = 'final-output';
        summary.textContent = item.completed_message;
        if (item.completed_at) {
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = `Completed at ${new Date(item.completed_at).toLocaleString()}`;
          summary.appendChild(meta);
        }
        card.appendChild(summary);
      }
      return card;
    }
    async function fetchConversations() {
      const res = await fetch('/list');
      const ids = await res.json();
      const container = document.getElementById('conversations');
      container.innerHTML = '';
      for (const id of ids) {
        try {
          const conv = await fetchConversation(id);
          renderConversation(conv);
        } catch (err) {
          const div = document.createElement('div');
          div.textContent = `Failed to load conversation ${id}: ${err.message}`;
          container.appendChild(div);
        }
      }
      fetchInbox();
    }
    function renderConversation(conv) {
      const domId = conv.session_id || conv.id;
      const div = document.createElement('div');
      div.className = 'conv';
      div.id = 'conv-' + domId;

      const titleRow = document.createElement('div');
      titleRow.style.display = 'flex';
      titleRow.style.justifyContent = 'space-between';
      const h3 = document.createElement('h3');
      h3.textContent = conv.prompt || 'Conversation';
      const actions = document.createElement('div');
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.onclick = async () => {
        if (!conv.session_id) return;
        const resp = await fetch('/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      const approveBtn = document.createElement('button');
      approveBtn.textContent = 'Approve Plan';
      approveBtn.onclick = async () => {
        const resp = await fetch('/conversation/approve-plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      const resumeBtn = document.createElement('button');
      resumeBtn.textContent = 'Resume';
      resumeBtn.onclick = async () => {
        const resp = await fetch('/conversation/resume', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      actions.appendChild(closeBtn);
      if (conv.state === 'awaiting_plan_approval') actions.appendChild(approveBtn);
      if (conv.state === 'blocked') actions.appendChild(resumeBtn);
      titleRow.appendChild(h3);
      titleRow.appendChild(actions);
      div.appendChild(titleRow);

      const session = document.createElement('div');
      session.className = 'session';
      if (conv.session_id) {
        session.textContent = `Codex session: ${conv.session_id}`;
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = async () => {
          try {
            await navigator.clipboard.writeText(conv.session_id);
            copyBtn.textContent = 'Copied';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          } catch (err) {
            copyBtn.textContent = 'Copy failed';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          }
        };
        session.appendChild(copyBtn);
      }
      div.appendChild(session);

      const meta = document.createElement('div');
      meta.className = 'status';
      meta.textContent = `State: ${conv.state || 'unknown'}${conv.awaiting_reason ? ' â€” ' + conv.awaiting_reason : ''}`;
      div.appendChild(meta);

      if (conv.prompt) {
        const promptBlock = document.createElement('div');
        promptBlock.className = 'prompt-block';
        promptBlock.textContent = `Prompt: ${conv.prompt}`;
        div.appendChild(promptBlock);
      }

      if (conv.plan_text) {
        const planTitle = document.createElement('div');
        planTitle.textContent = 'Plan:';
        const plan = document.createElement('pre');
        plan.className = 'raw-output';
        plan.textContent = conv.plan_text;
        div.appendChild(planTitle);
        div.appendChild(plan);
      }

      const artifactsSection = document.createElement('div');
      artifactsSection.className = 'artifact-section';
      div.appendChild(artifactsSection);

      const input = document.createElement('input');
      input.type = 'text';
      input.id = `newMessage-${domId}`;
      input.placeholder = 'Send a chat message...';
      const msgsDiv = document.createElement('div');
      msgsDiv.className = 'messages';
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.onclick = async () => {
        const text = input.value.trim();
        if (!text) return;
        addMessage(msgsDiv, 'user', text);
        sendBtn.disabled = true;
        input.disabled = true;
        try {
          const resp = await fetch('/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: conv.session_id || '', message: text })
          });
          if (!resp.ok) {
            addMessage(msgsDiv, 'error', await resp.text());
          } else {
            const data = await resp.json();
            addMessage(msgsDiv, 'assistant', data.reply, data.duration_ms ? formatSeconds(data.duration_ms) : null, data.raw_output, data.prompt);
          }
        } catch (err) {
          addMessage(msgsDiv, 'error', err.message);
        }
        sendBtn.disabled = false;
        input.disabled = false;
        input.value = '';
      };
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendBtn.click();
        }
      });

      renderArtifacts(artifactsSection, conv, input);

      if (Array.isArray(conv.steps) && conv.steps.length) {
        const stepsList = document.createElement('div');
        stepsList.innerHTML = '<div><strong>Steps</strong></div>';
        conv.steps.forEach((step) => {
          const sdiv = document.createElement('div');
          sdiv.className = 'status';
          sdiv.innerHTML = `<span class="pill">${step.status}</span> ${step.title}`;
          if (step.pending_command) {
            const cmdSpan = document.createElement('div');
            cmdSpan.className = 'status';
            cmdSpan.textContent = `Pending command: ${step.pending_command}`;
            const approveCmd = document.createElement('button');
            approveCmd.textContent = 'Approve Command';
            approveCmd.onclick = async () => {
              const resp = await fetch('/conversation/approve-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: conv.session_id, step_id: step.id })
              });
              if (!resp.ok) alert(await resp.text());
              else await fetchConversations();
            };
            cmdSpan.appendChild(approveCmd);
            sdiv.appendChild(cmdSpan);
          }
          if (step.logs && step.logs.length) {
            const details = document.createElement('details');
            const summary = document.createElement('summary');
            summary.textContent = 'Logs';
            details.appendChild(summary);
            step.logs.forEach((logLine) => {
              const l = document.createElement('div');
              l.textContent = logLine;
              details.appendChild(l);
            });
            sdiv.appendChild(details);
          }
          stepsList.appendChild(sdiv);
        });
        div.appendChild(stepsList);
      }

      const modelCalls = Array.isArray(conv.model_calls) ? conv.model_calls : [];
      const assistantMessages = (conv.messages || []).filter((m) => m.role === 'assistant');
      const lastAssistant = assistantMessages[assistantMessages.length - 1];
      const finalCall = modelCalls[modelCalls.length - 1] || {};
      const finalText = conv.completed_message || (lastAssistant && lastAssistant.content) || finalCall.reply || 'Awaiting response...';
      const finalOutput = document.createElement('div');
      finalOutput.className = 'final-output';
      const finalLabel = document.createElement('div');
      finalLabel.textContent = 'Final output response';
      finalOutput.appendChild(finalLabel);
      const finalBody = document.createElement('div');
      finalBody.textContent = finalText;
      finalOutput.appendChild(finalBody);
      if (conv.completed_at) {
        const finalMeta = document.createElement('div');
        finalMeta.className = 'meta';
        finalMeta.textContent = `Completed at ${new Date(conv.completed_at).toLocaleString()}`;
        finalOutput.appendChild(finalMeta);
      }
      if (finalCall.duration_ms || finalCall.raw_output) {
        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.textContent = `Last call duration: ${finalCall.duration_ms ? formatSeconds(finalCall.duration_ms) : 'n/a'}`;
        finalOutput.appendChild(meta);
        if (finalCall.raw_output) {
          const details = document.createElement('details');
          const summary = document.createElement('summary');
          summary.textContent = 'Raw output';
          details.appendChild(summary);
          const pre = document.createElement('pre');
          pre.className = 'raw-output';
          pre.textContent = finalCall.raw_output;
          details.appendChild(pre);
          finalOutput.appendChild(details);
        }
      }
      div.appendChild(finalOutput);

      div.appendChild(msgsDiv);
      div.appendChild(input);
      div.appendChild(sendBtn);

      let assistantIdx = 0;
      (conv.messages || []).forEach((m) => {
        if (m.role === 'assistant') {
          const call = modelCalls[assistantIdx] || {};
          const metaMsg = call.duration_ms != null ? formatSeconds(call.duration_ms) : null;
          addMessage(msgsDiv, m.role, m.content, metaMsg, call.raw_output, call.prompt);
          assistantIdx += 1;
        } else {
          addMessage(msgsDiv, m.role, m.content);
        }
      });

      document.getElementById('conversations').appendChild(div);
    }
    function formatCodexEvents(raw) {
      if (!raw) return '';
      return raw.split('\n').map((line) => {
        try {
          const evt = JSON.parse(line);
          const parts = [];
          if (evt.type) parts.push(evt.type);
          if (evt.thread_id) parts.push(`thread:${evt.thread_id}`);
          if (evt.item && evt.item.type) parts.push(`item:${evt.item.type}`);
          return parts.length ? parts.join(' | ') : line;
        } catch (_) {
          return line;
        }
      }).join('\n');
    }

function addMessage(container, role, text, meta, rawOutput, promptText) {
  const wrapper = document.createElement('div');
  wrapper.className = 'msg ' + role;
  const line = document.createElement('div');
      const label = meta ? `${role} (${meta})` : role;
      line.textContent = label + ': ' + text;
      wrapper.appendChild(line);
      if (rawOutput) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'Codex raw output';
        const pre = document.createElement('pre');
        pre.className = 'raw-output';
        pre.textContent = formatCodexEvents(rawOutput);
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }
      if (promptText) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'Prompt sent';
        const pre = document.createElement('pre');
        pre.className = 'raw-output';
        pre.textContent = promptText;
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }
  container.appendChild(wrapper);
}

function renderArtifacts(container, conv, input) {
  if (!container) {
    return;
  }
  container.innerHTML = '<div><strong>Artifacts</strong></div>';
  if (!Array.isArray(conv.artifacts) || conv.artifacts.length === 0) {
    container.innerHTML += '<div class="status">No cached artifacts.</div>';
    return;
  }
  conv.artifacts.forEach((artifact) => {
    const card = document.createElement('div');
    card.className = 'artifact-card';
    const title = document.createElement('div');
    title.textContent = `${artifact.title}${artifact.source ? ' (' + artifact.source + ')' : ''}`;
    card.appendChild(title);
    if (artifact.description) {
      const desc = document.createElement('div');
      desc.className = 'status';
      desc.textContent = artifact.description;
      card.appendChild(desc);
    }
    if (artifact.created_at) {
      const created = document.createElement('div');
      created.className = 'status';
      created.textContent = `Captured: ${artifact.created_at}`;
      card.appendChild(created);
    }
    const pre = document.createElement('pre');
    pre.className = 'raw-output';
    pre.textContent = artifact.content;
    card.appendChild(pre);
    const useBtn = document.createElement('button');
    useBtn.textContent = 'Use in prompt';
    useBtn.onclick = () => {
      input.value = artifact.content;
      input.focus();
    };
    card.appendChild(useBtn);
    container.appendChild(card);
  });
}

    const startBtn = document.getElementById('startBtn');
    const promptField = document.getElementById('promptInput');
    startBtn.onclick = async () => {
      const prompt = promptField.value.trim();
      if (!prompt) return;
      const resp = await fetch('/conversation/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt })
      });
      if (!resp.ok) {
        alert(await resp.text());
        return;
      }
      document.getElementById('promptInput').value = '';
      await fetchConversations();
    };
    promptField.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        startBtn.click();
      }
    });
    document.getElementById('themeToggle').onclick = () => {
      const isDark = document.body.classList.contains('dark');
      applyTheme(isDark ? 'light' : 'dark');
    };

    initTheme();
    fetchConversations();
    fetchInbox();
  </script>
</body>
</html>
