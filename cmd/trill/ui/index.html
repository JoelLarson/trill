<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trill</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #f9fafb;
      --fg: #1c1f26;
      --muted: #666;
      --border: #d0d7de;
      --panel: #ffffff;
      --user: #1d4ed8;
      --assistant: #15803d;
      --error: #b00020;
      --raw-bg: #f2f4f7;
    }
    body.dark {
      --bg: #0d1117;
      --fg: #e6edf3;
      --muted: #9da8b7;
      --border: #2d3748;
      --panel: #161b22;
      --user: #60a5fa;
      --assistant: #34d399;
      --error: #ff6b6b;
      --raw-bg: #1f2733;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background: var(--bg);
      color: var(--fg);
    }
    #conversations { margin-top: 10px; }
    .toolbar { display: flex; gap: 10px; align-items: center; margin-bottom: 12px; }
    button { cursor: pointer; }
    input[type="text"] { padding: 6px; }
    .conv { border: 1px solid var(--border); padding: 10px; margin-bottom: 10px; background: var(--panel); }
    .messages { max-height: 200px; overflow-y: auto; border-top: 1px solid var(--border); padding-top: 5px; }
    .msg { margin: 6px 0; }
    .msg.user { color: var(--user); }
    .msg.assistant { color: var(--assistant); }
    .msg.error { color: var(--error); font-style: italic; }
    .status { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .raw-output { background: var(--raw-bg); border: 1px dashed var(--border); padding: 6px; margin-top: 4px; white-space: pre-wrap; font-size: 12px; color: var(--fg); }
    .session { font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    .session button { margin-left: 6px; }
    .pill { display: inline-block; padding: 2px 6px; border-radius: 4px; border: 1px solid var(--border); margin-right: 6px; }
  </style>
</head>
<body>
  <h1>Trill</h1>
  <div class="toolbar">
    <input id="promptInput" type="text" placeholder="Enter prompt..." style="flex:1;" />
    <button id="startBtn">Start New Conversation</button>
    <button id="themeToggle">Toggle Theme</button>
  </div>
  <div id="inbox"></div>
  <div id="conversations"></div>

  <script>
    const formatSeconds = (ms) => (ms / 1000).toFixed(1) + 's';
    const applyTheme = (mode) => {
      document.body.classList.toggle('dark', mode === 'dark');
      localStorage.setItem('theme', mode);
    };
    const initTheme = () => {
      const stored = localStorage.getItem('theme');
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      applyTheme(stored || (prefersDark ? 'dark' : 'light'));
    };
    const fetchConversation = async (id) => {
      const res = await fetch(`/conversation?id=${encodeURIComponent(id)}`);
      if (!res.ok) throw new Error(await res.text() || res.statusText);
      return res.json();
    };
    async function fetchInbox() {
      const res = await fetch('/inbox');
      const list = await res.json();
      const box = document.getElementById('inbox');
      box.innerHTML = '<h3>Inbox</h3>';
      if (!Array.isArray(list) || list.length === 0) {
        box.innerHTML += '<div>No items waiting.</div>';
        return;
      }
      list.forEach(item => {
        const div = document.createElement('div');
        div.textContent = `${item.state}: ${item.prompt || ''} ${item.awaiting_reason ? '— ' + item.awaiting_reason : ''}`;
        box.appendChild(div);
      });
    }
    async function fetchConversations() {
      const res = await fetch('/list');
      const ids = await res.json();
      const container = document.getElementById('conversations');
      container.innerHTML = '';
      for (const id of ids) {
        try {
          const conv = await fetchConversation(id);
          renderConversation(conv);
        } catch (err) {
          const div = document.createElement('div');
          div.textContent = `Failed to load conversation ${id}: ${err.message}`;
          container.appendChild(div);
        }
      }
      fetchInbox();
    }
    function renderConversation(conv) {
      const domId = conv.session_id || conv.id;
      const div = document.createElement('div');
      div.className = 'conv';
      div.id = 'conv-' + domId;

      const titleRow = document.createElement('div');
      titleRow.style.display = 'flex';
      titleRow.style.justifyContent = 'space-between';
      const h3 = document.createElement('h3');
      h3.textContent = conv.prompt || 'Conversation';
      const actions = document.createElement('div');
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.onclick = async () => {
        if (!conv.session_id) return;
        const resp = await fetch('/close', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      const approveBtn = document.createElement('button');
      approveBtn.textContent = 'Approve Plan';
      approveBtn.onclick = async () => {
        const resp = await fetch('/conversation/approve-plan', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      const resumeBtn = document.createElement('button');
      resumeBtn.textContent = 'Resume';
      resumeBtn.onclick = async () => {
        const resp = await fetch('/conversation/resume', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id: conv.session_id })
        });
        if (!resp.ok) alert(await resp.text());
        else await fetchConversations();
      };
      actions.appendChild(closeBtn);
      if (conv.state === 'awaiting_plan_approval') actions.appendChild(approveBtn);
      if (conv.state === 'blocked') actions.appendChild(resumeBtn);
      titleRow.appendChild(h3);
      titleRow.appendChild(actions);
      div.appendChild(titleRow);

      const meta = document.createElement('div');
      meta.className = 'status';
      meta.textContent = `State: ${conv.state || 'unknown'}${conv.awaiting_reason ? ' — ' + conv.awaiting_reason : ''}`;
      div.appendChild(meta);

      const session = document.createElement('div');
      session.className = 'session';
      if (conv.session_id) {
        session.textContent = `Codex session: ${conv.session_id}`;
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = async () => {
          try {
            await navigator.clipboard.writeText(conv.session_id);
            copyBtn.textContent = 'Copied';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          } catch (err) {
            copyBtn.textContent = 'Copy failed';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          }
        };
        session.appendChild(copyBtn);
      }
      div.appendChild(session);

      if (conv.plan_text) {
        const planTitle = document.createElement('div');
        planTitle.textContent = 'Plan:';
        const plan = document.createElement('pre');
        plan.className = 'raw-output';
        plan.textContent = conv.plan_text;
        div.appendChild(planTitle);
        div.appendChild(plan);
      }

      if (Array.isArray(conv.steps) && conv.steps.length) {
        const stepsList = document.createElement('div');
        stepsList.innerHTML = '<div><strong>Steps</strong></div>';
        conv.steps.forEach((step) => {
          const sdiv = document.createElement('div');
          sdiv.className = 'status';
          sdiv.innerHTML = `<span class="pill">${step.status}</span> ${step.title}`;
          if (step.pending_command) {
            const cmdSpan = document.createElement('div');
            cmdSpan.className = 'status';
            cmdSpan.textContent = `Pending command: ${step.pending_command}`;
            const approveCmd = document.createElement('button');
            approveCmd.textContent = 'Approve Command';
            approveCmd.onclick = async () => {
              const resp = await fetch('/conversation/approve-command', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: conv.session_id, step_id: step.id })
              });
              if (!resp.ok) alert(await resp.text());
              else await fetchConversations();
            };
            cmdSpan.appendChild(approveCmd);
            sdiv.appendChild(cmdSpan);
          }
          if (step.logs && step.logs.length) {
            const details = document.createElement('details');
            const summary = document.createElement('summary');
            summary.textContent = 'Logs';
            details.appendChild(summary);
            step.logs.forEach((logLine) => {
              const l = document.createElement('div');
              l.textContent = logLine;
              details.appendChild(l);
            });
            sdiv.appendChild(details);
          }
          stepsList.appendChild(sdiv);
        });
        div.appendChild(stepsList);
      }

      const msgsDiv = document.createElement('div');
      msgsDiv.className = 'messages';
      div.appendChild(msgsDiv);
      const input = document.createElement('input');
      input.type = 'text';
      input.id = `newMessage-${domId}`;
      input.placeholder = 'Send a chat message...';
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.onclick = async () => {
        const text = input.value.trim();
        if (!text) return;
        addMessage(msgsDiv, 'user', text);
        sendBtn.disabled = true;
        input.disabled = true;
        try {
          const resp = await fetch('/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: conv.session_id || '', message: text })
          });
          if (!resp.ok) {
            addMessage(msgsDiv, 'error', await resp.text());
          } else {
            const data = await resp.json();
            addMessage(msgsDiv, 'assistant', data.reply, data.duration_ms ? formatSeconds(data.duration_ms) : null, data.raw_output, data.prompt);
          }
        } catch (err) {
          addMessage(msgsDiv, 'error', err.message);
        }
        sendBtn.disabled = false;
        input.disabled = false;
        input.value = '';
      };
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendBtn.click();
        }
      });
      div.appendChild(input);
      div.appendChild(sendBtn);

      // Render existing messages
      let assistantIdx = 0;
      const modelCalls = Array.isArray(conv.model_calls) ? conv.model_calls : [];
      (conv.messages || []).forEach((m) => {
        if (m.role === 'assistant') {
          const call = modelCalls[assistantIdx] || {};
          const metaMsg = call.duration_ms != null ? formatSeconds(call.duration_ms) : null;
          addMessage(msgsDiv, m.role, m.content, metaMsg, call.raw_output, call.prompt);
          assistantIdx += 1;
        } else {
          addMessage(msgsDiv, m.role, m.content);
        }
      });

      document.getElementById('conversations').appendChild(div);
    }
    function formatCodexEvents(raw) {
      if (!raw) return '';
      return raw.split('\n').map((line) => {
        try {
          const evt = JSON.parse(line);
          const parts = [];
          if (evt.type) parts.push(evt.type);
          if (evt.thread_id) parts.push(`thread:${evt.thread_id}`);
          if (evt.item && evt.item.type) parts.push(`item:${evt.item.type}`);
          return parts.length ? parts.join(' | ') : line;
        } catch (_) {
          return line;
        }
      }).join('\n');
    }

    function addMessage(container, role, text, meta, rawOutput, promptText) {
      const wrapper = document.createElement('div');
      wrapper.className = 'msg ' + role;
      const line = document.createElement('div');
      const label = meta ? `${role} (${meta})` : role;
      line.textContent = label + ': ' + text;
      wrapper.appendChild(line);
      if (rawOutput) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'Codex raw output';
        const pre = document.createElement('pre');
        pre.className = 'raw-output';
        pre.textContent = formatCodexEvents(rawOutput);
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }
      if (promptText) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'Prompt sent';
        const pre = document.createElement('pre');
        pre.className = 'raw-output';
        pre.textContent = promptText;
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }
      container.appendChild(wrapper);
    }

    document.getElementById('startBtn').onclick = async () => {
      const prompt = document.getElementById('promptInput').value.trim();
      if (!prompt) return;
      const resp = await fetch('/conversation/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt })
      });
      if (!resp.ok) {
        alert(await resp.text());
        return;
      }
      document.getElementById('promptInput').value = '';
      await fetchConversations();
    };
    document.getElementById('themeToggle').onclick = () => {
      const isDark = document.body.classList.contains('dark');
      applyTheme(isDark ? 'light' : 'dark');
    };

    initTheme();
    fetchConversations();
    fetchInbox();
  </script>
</body>
</html>
