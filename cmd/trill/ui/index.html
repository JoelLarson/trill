<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agent Manager UI</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #conversations { margin-bottom: 20px; }
    .conv { border: 1px solid #ccc; padding: 10px; margin-bottom: 10px; }
    .messages { max-height: 200px; overflow-y: auto; border-top: 1px solid #eee; padding-top: 5px; }
    .msg { margin: 6px 0; }
    .msg.user { color: #0066cc; }
    .msg.assistant { color: #008000; }
    .msg.error { color: #b00020; font-style: italic; }
    #newMessage { width: 80%; }
    .status { font-size: 12px; color: #666; margin-top: 6px; }
    .raw-output { background: #f7f7f7; border: 1px dashed #ccc; padding: 6px; margin-top: 4px; white-space: pre-wrap; font-size: 12px; }
    .session { font-size: 12px; color: #444; margin-bottom: 6px; }
    .session button { margin-left: 6px; }
  </style>
</head>
<body>
  <h1>Agent Manager</h1>
  <button id="startBtn">Start New Conversation</button>
  <div id="conversations"></div>

  <script>
    const apiBase = '';
    const formatSeconds = (ms) => (ms / 1000).toFixed(1) + 's';
    let pendingConversations = [];
    const fetchConversation = async (id) => {
      const res = await fetch(`/conversation?id=${encodeURIComponent(id)}`);
      if (!res.ok) throw new Error(await res.text() || res.statusText);
      return res.json();
    };
    async function fetchConversations() {
      const res = await fetch('/list');
      const ids = await res.json();
      const container = document.getElementById('conversations');
      container.innerHTML = '';
      pendingConversations = pendingConversations.filter(c => !c.session_id);
      pendingConversations.forEach(conv => renderConversation(conv));
      for (const id of ids) {
        try {
          const conv = await fetchConversation(id);
          renderConversation(conv);
        } catch (err) {
          const div = document.createElement('div');
          div.textContent = `Failed to load conversation ${id}: ${err.message}`;
          container.appendChild(div);
        }
      }
    }
    async function renderConversation(conv) {
      const domId = conv.session_id || conv.id || conv.local_id;
      const div = document.createElement('div');
      div.className = 'conv';
      div.id = 'conv-' + domId;
      const title = document.createElement('h3');
      title.textContent = 'Conversation';
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.style.marginLeft = '10px';
      closeBtn.onclick = async () => {
        // Pending chat: just remove locally.
        if (!conv.session_id) {
          pendingConversations = pendingConversations.filter(c => c !== conv);
          div.remove();
          return;
        }
        closeBtn.disabled = true;
        try {
          const resp = await fetch('/close', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: conv.session_id })
          });
          if (!resp.ok) {
            const errText = await resp.text();
            alert(`Close failed: ${errText || resp.statusText}`);
          } else {
            div.remove();
            await fetchConversations();
          }
        } catch (err) {
          alert(`Close failed: ${err.message}`);
        } finally {
          closeBtn.disabled = false;
        }
      };
      title.appendChild(closeBtn);
      div.appendChild(title);
      const session = document.createElement('div');
      session.className = 'session';
      const setSessionText = (sid) => {
        if (!sid) {
          session.textContent = 'Codex session: pending...';
          return;
        }
        session.textContent = `Codex session: ${sid}`;
        const copyBtn = document.createElement('button');
        copyBtn.textContent = 'Copy';
        copyBtn.onclick = async () => {
          try {
            await navigator.clipboard.writeText(sid);
            copyBtn.textContent = 'Copied';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          } catch (err) {
            copyBtn.textContent = 'Copy failed';
            setTimeout(() => (copyBtn.textContent = 'Copy'), 1200);
          }
        };
        session.appendChild(copyBtn);
      };
      setSessionText(conv.session_id);
      div.appendChild(session);
      const msgsDiv = document.createElement('div');
      msgsDiv.className = 'messages';
      div.appendChild(msgsDiv);
      const status = document.createElement('div');
      status.className = 'status';
      status.textContent = '';
      div.appendChild(status);
      const input = document.createElement('input');
      input.type = 'text';
        input.id = `newMessage-${domId}`;
      input.placeholder = 'Enter message...';
      const sendBtn = document.createElement('button');
      sendBtn.textContent = 'Send';
      sendBtn.onclick = async () => {
        const text = input.value.trim();
        if (!text) return;
        addMessage(msgsDiv, 'user', text);
        const start = performance.now();
        const updateStatus = () => {
          status.textContent = 'Processing... ' + formatSeconds(performance.now() - start);
        };
        updateStatus();
        const timer = setInterval(updateStatus, 200);
        sendBtn.disabled = true;
        input.disabled = true;
        let outcome = 'Completed';
        let pendingAssistantReply = null;
        let pendingRawOutput = null;
        let pendingDuration = null;
        let newSessionId = null;
        try {
          const resp = await fetch('/send', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: conv.session_id || '', message: text })
          });
          if (!resp.ok) {
            const errorText = await resp.text();
            addMessage(msgsDiv, 'error', `Failed to send: ${errorText || resp.statusText}`);
            outcome = 'Failed';
          } else {
            const data = await resp.json();
            pendingAssistantReply = data.reply;
            pendingRawOutput = data.raw_output;
            pendingDuration = data.duration_ms;
            newSessionId = data.session_id;
            conv.session_id = data.session_id;
            conv.id = data.session_id;
            conv.messages = conv.messages || [];
            conv.model_calls = conv.model_calls || [];
            conv.messages.push({ role: 'user', content: text });
            conv.messages.push({ role: 'assistant', content: data.reply });
            conv.model_calls.push({
              prompt: data.prompt,
              raw_output: data.raw_output,
              reply: data.reply,
              duration_ms: data.duration_ms,
              session_id: data.session_id
            });
          }
        } catch (err) {
          addMessage(msgsDiv, 'error', `Network error: ${err.message}`);
          outcome = 'Failed';
        }
        const elapsed = formatSeconds(performance.now() - start);
        clearInterval(timer);
        status.textContent = `${outcome} in ${elapsed}`;
        if (pendingAssistantReply !== null) {
          const meta = pendingDuration != null ? formatSeconds(pendingDuration) : elapsed;
          addMessage(msgsDiv, 'assistant', pendingAssistantReply, meta, pendingRawOutput);
        }
        if (newSessionId) {
          setSessionText(newSessionId);
          // remove from pending list now that session exists
          pendingConversations = pendingConversations.filter(c => c !== conv);
          fetchConversations();
        }
        sendBtn.disabled = false;
        input.disabled = false;
        input.value = '';
      };
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendBtn.click();
        }
      });
      div.appendChild(input);
      div.appendChild(sendBtn);
      document.getElementById('conversations').appendChild(div);
      // Render existing messages (including previous Codex raw output).
      let assistantIdx = 0;
      const modelCalls = Array.isArray(conv.model_calls) ? conv.model_calls : [];
      conv.messages.forEach((m) => {
        if (m.role === 'assistant') {
          const call = modelCalls[assistantIdx] || {};
          const meta = call.duration_ms != null ? formatSeconds(call.duration_ms) : null;
          addMessage(msgsDiv, m.role, m.content, meta, call.raw_output);
          assistantIdx += 1;
        } else {
          addMessage(msgsDiv, m.role, m.content);
        }
      });
    }
    function addMessage(container, role, text, meta, rawOutput) {
      const wrapper = document.createElement('div');
      wrapper.className = 'msg ' + role;
      const line = document.createElement('div');
      const label = meta ? `${role} (${meta})` : role;
      line.textContent = label + ': ' + text;
      wrapper.appendChild(line);
      if (rawOutput) {
        const details = document.createElement('details');
        const summary = document.createElement('summary');
        summary.textContent = 'Codex raw output';
        const pre = document.createElement('pre');
        pre.className = 'raw-output';
        pre.textContent = rawOutput;
        details.appendChild(summary);
        details.appendChild(pre);
        wrapper.appendChild(details);
      }
      container.appendChild(wrapper);
    }
    document.getElementById('startBtn').onclick = async () => {
      const conv = { local_id: `pending-${Date.now()}-${Math.random().toString(16).slice(2)}`, messages: [], model_calls: [], session_id: null };
      pendingConversations.push(conv);
      renderConversation(conv);
    };
    // initial load
    fetchConversations();
  </script>
</body>
</html>
